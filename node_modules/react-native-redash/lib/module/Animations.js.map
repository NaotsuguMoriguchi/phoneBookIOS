{"version":3,"sources":["Animations.ts"],"names":["Animated","block","defined","max","min","Value","set","add","multiply","cond","eq","abs","sub","not","lessThan","greaterThan","divide","modulo","proc","diff","v","stash","prev","diffClamp","a","minVal","maxVal","value","moving","position","minPositionDelta","emptyFrameThreshold","delta","noMovementFrames","snapPoint","velocity","points","point","diffPoint","p","deltas","map","minDelta","reduce","acc","addTo","node","subTo","multiplyTo","divideTo","moduloTo"],"mappings":"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","sourcesContent":["import Animated, { block, defined } from \"react-native-reanimated\";\n\nimport { max, min } from \"./Math\";\n\nconst {\n  Value,\n  set,\n  add,\n  multiply,\n  cond,\n  eq,\n  abs,\n  sub,\n  not,\n  lessThan,\n  greaterThan,\n  divide,\n  modulo,\n  proc,\n} = Animated;\n\nexport type SpringConfig = Partial<Omit<Animated.SpringConfig, \"toValue\">>;\nexport type TimingConfig = Partial<Omit<Animated.TimingConfig, \"toValue\">>;\n\n// currently diffClamp() from reanimated seems currently buggy because of proc()\nexport const diff = (v: Animated.Node<number>) => {\n  const stash = new Value(0);\n  const prev = new Value<number>();\n  return block([\n    set(stash, cond(defined(prev), sub(v, prev), 0)),\n    set(prev, v),\n    stash,\n  ]);\n};\n\nexport const diffClamp = (\n  a: Animated.Node<number>,\n  minVal: Animated.Adaptable<number>,\n  maxVal: Animated.Adaptable<number>\n) => {\n  const value = new Value<number>();\n  return set(\n    value,\n    min(max(add(cond(defined(value), value, a), diff(a)), minVal), maxVal)\n  );\n};\n\nexport const moving = (\n  position: Animated.Node<number>,\n  minPositionDelta = 1e-3,\n  emptyFrameThreshold = 5\n) => {\n  const delta = diff(position);\n  const noMovementFrames = new Value(0);\n  return cond(\n    lessThan(abs(delta), minPositionDelta),\n    [\n      set(noMovementFrames, add(noMovementFrames, 1)),\n      not(greaterThan(noMovementFrames, emptyFrameThreshold)),\n    ],\n    [set(noMovementFrames, 0), 1]\n  );\n};\n\nexport const snapPoint = (\n  value: Animated.Adaptable<number>,\n  velocity: Animated.Adaptable<number>,\n  points: Animated.Adaptable<number>[]\n) => {\n  const point = add(value, multiply(0.2, velocity));\n  const diffPoint = (p: Animated.Adaptable<number>) => abs(sub(point, p));\n  const deltas = points.map((p) => diffPoint(p));\n  const minDelta = min(...deltas);\n  return points.reduce(\n    (acc, p) => cond(eq(diffPoint(p), minDelta), p, acc),\n    new Value()\n  ) as Animated.Node<number>;\n};\n\nexport const addTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, add(value, node))\n);\n\nexport const subTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, sub(value, node))\n);\n\nexport const multiplyTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, multiply(value, node))\n);\n\nexport const divideTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, divide(value, node))\n);\n\nexport const moduloTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, modulo(value, node))\n);\n"]}